# ==== ЭТАП 0: ОЧИСТКА РЕПОЗИТОРИЯ ====

# Создать корневой .gitignore
cat > .gitignore << 'EOF'
# Virtual Environment
venv/
env/
.venv/
backend/venv/
backend/venvpwdpwd/

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
*.py[cod]
*$py.class
*.so
*.egg
*.egg-info/
dist/
build/
eggs/
parts/
bin/
var/
sdist/
develop-eggs/
.installed.cfg
lib/
lib64/

# Django
*.log
db.sqlite3
db.sqlite3-journal
*.pot
local_settings.py
media/
staticfiles/
static/
uploads/

# Node.js
node_modules/
frontend/node_modules/
frontend/dist/
frontend/build/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.pydevproject

# OS
.DS_Store
Thumbs.db
Desktop.ini

# Environment variables
.env
.env.local
.env.development
.env.production
.env.test
*.env

# Security files
login.json
*.key
*.pem
*.crt

# Cache
*.cache
.cache/
.npm-cache/

# Coverage
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/
cover/

# Repomix
repomix-output.xml
EOF

# Удалить чувствительные файлы и мусор
git rm -rf backend/venv backend/__pycache__ backend/apps/__pycache__
git rm -rf backend/apps/*/migrations/ backend/apps/*/__pycache__
git rm -rf backend/db.sqlite3 backend/login.json
git rm -rf frontend/.npm-cache

# Первый коммит
git add .gitignore
git commit -m "ЭТАП 0: Критическая очистка репозитория"

# ==== ЭТАП 1: БЕЗОПАСНОСТЬ ====

cat > backend/requirements.txt << 'EOF'
Django>=5.0.7,<6.0.0
djangorestframework>=3.15.0
djangorestframework-simplejwt>=5.3.0
channels>=4.0.0
channels-redis>=4.1.0
daphne>=4.0.0
django-filter>=24.0
python-decouple>=3.8
psycopg2-binary>=2.9.9
python-dotenv>=1.0.0
EOF

cat > backend/.env.example << 'EOF'
SECRET_KEY=your-super-secret-key-change-in-production
DEBUG=True
DATABASE_URL=sqlite:///db.sqlite3
REDIS_URL=redis://127.0.0.1:6379
ALLOWED_HOSTS=localhost,127.0.0.1
CORS_ALLOWED_ORIGINS=http://localhost:5173,http://127.0.0.1:5173
EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend
EMAIL_HOST=
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=
EMAIL_HOST_PASSWORD=
JWT_ACCESS_TOKEN_LIFETIME_MINUTES=60
JWT_REFRESH_TOKEN_LIFETIME_DAYS=7
EOF

cd backend && SECRET_KEY=$(python -c "from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())")
cat > backend/.env << EOF
SECRET_KEY=$SECRET_KEY
DEBUG=True
DATABASE_URL=sqlite:///db.sqlite3
REDIS_URL=redis://127.0.0.1:6379
ALLOWED_HOSTS=localhost,127.0.0.1
CORS_ALLOWED_ORIGINS=http://localhost:5173,http://127.0.0.1:5173
EOF

cat > backend/config/settings.py << 'EOF'
"""
Django settings for config project.
"""
from pathlib import Path
import sys
import os
from decouple import config

BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))

SECRET_KEY = config('SECRET_KEY')
DEBUG = config('DEBUG', default=False, cast=bool)
ALLOWED_HOSTS = config('ALLOWED_HOSTS', default='').split(',')

DJANGO_APPS = [
    'daphne',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

THIRD_PARTY_APPS = [
    'corsheaders',
    'rest_framework',
    'rest_framework_simplejwt',
    'channels',
    'django_filters',
]

LOCAL_APPS = [
    'apps.users',
    'apps.suppliers',
    'apps.orders',
    'apps.subscriptions',
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'
ASGI_APPLICATION = 'config.asgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True
STATIC_URL = 'static/'
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
AUTH_USER_MODEL = "users.User"
MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")

CORS_ALLOWED_ORIGINS = config('CORS_ALLOWED_ORIGINS', default='').split(',')

REST_FRAMEWORK = {
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
        "rest_framework.filters.SearchFilter",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
}

from datetime import timedelta

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=config('JWT_ACCESS_TOKEN_LIFETIME_MINUTES', default=60, cast=int)),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=config('JWT_REFRESH_TOKEN_LIFETIME_DAYS', default=7, cast=int)),
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
}

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [config('REDIS_URL')],
        },
    },
}
EOF

cat > backend/config/asgi.py << 'EOF'
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
import apps.orders.routing

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            apps.orders.routing.websocket_urlpatterns
        )
    ),
})
EOF

pip install -r backend/requirements.txt
git add backend/.env.example backend/.env backend/requirements.txt backend/config/settings.py backend/config/asgi.py
git commit -m "ЭТАП 1: Безопасность"

# ==== ЭТАП 2: МИГРАЦИИ ====

find backend/apps -name "migrations" -type d -exec rm -rf {} + 2>/dev/null
cd backend && python manage.py makemigrations users suppliers orders subscriptions
cd backend && python manage.py migrate
git add backend/apps/*/migrations/
git commit -m "ЭТАП 2: Миграции"

# ==== ЭТАП 3: API БАГИ ====

cat > backend/apps/suppliers/urls.py << 'EOF'
from django.urls import path
from .views import SupplierListAPIView, supplier_contacts

app_name = "suppliers"

urlpatterns = [
    path("", SupplierListAPIView.as_view(), name="supplier-list"),
    path("<int:pk>/contacts/", supplier_contacts, name="supplier-contacts"),
]
EOF

cat > backend/apps/orders/urls.py << 'EOF'
from django.urls import path
from .views import OrderListAPIView, OrderCreateAPIView, OfferCreateAPIView

app_name = "orders"

urlpatterns = [
    path("", OrderListAPIView.as_view(), name="order-list"),
    path("create/", OrderCreateAPIView.as_view(), name="order-create"),
    path("<int:order_id>/offers/", OfferCreateAPIView.as_view(), name="offer-create"),
]
EOF

cat > backend/apps/users/views.py << 'EOF'
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import get_user_model
from rest_framework.permissions import AllowAny
from rest_framework_simplejwt.tokens import RefreshToken

User = get_user_model()

class RegisterView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request):
        email = request.data.get('email')
        password = request.data.get('password')
        
        if not email or not password:
            return Response(
                {"error": "Email и пароль обязательны"}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if len(password) < 8:
            return Response(
                {"error": "Пароль должен быть минимум 8 символов"}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if User.objects.filter(email=email).exists():
            return Response(
                {"error": "Пользователь с таким email уже существует"}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        user = User.objects.create_user(email=email, password=password)
        refresh = RefreshToken.for_user(user)
        
        return Response({
            "message": "Регистрация успешна",
            "user_id": user.id,
            "refresh": str(refresh),
            "access": str(refresh.access_token),
        }, status=status.HTTP_201_CREATED)
EOF

cat > backend/apps/users/models.py << 'EOF'
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.core.validators import EmailValidator

class User(AbstractUser):
    username = None
    email = models.EmailField(
        "Email", 
        unique=True, 
        validators=[EmailValidator],
        error_messages={
            'unique': "Пользователь с таким email уже существует.",
        }
    )
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    def __str__(self):
        return self.email
EOF

git add backend/apps/suppliers/urls.py backend/apps/orders/urls.py backend/apps/users/views.py backend/apps/users/models.py
git commit -m "ЭТАП 3: Исправлены API баги"

# ==== ЭТАП 4: МОДЕЛИ ====

cat > backend/apps/suppliers/models.py << 'EOF'
from django.db import models
from django.core.validators import MinValueValidator, URLValidator
from django.core.exceptions import ValidationError

class Category(models.Model):
    name = models.CharField("Категория", max_length=100, unique=True)
    slug = models.SlugField("Слаг", unique=True)
    description = models.TextField("Описание", blank=True)
    
    class Meta:
        verbose_name = "Категория"
        verbose_name_plural = "Категории"
        ordering = ["name"]

    def __str__(self):
        return self.name

class LogisticsCompany(models.Model):
    name = models.CharField("Логистическая компания", max_length=150, unique=True)
    site = models.URLField("Сайт", blank=True, validators=[URLValidator()])
    description = models.TextField("Описание", blank=True)
    
    class Meta:
        verbose_name = "Логистическая компания"
        verbose_name_plural = "Логистические компании"
        ordering = ["name"]

    def __str__(self):
        return self.name

class Supplier(models.Model):
    name = models.CharField("Название", max_length=150)
    country = models.CharField("Страна", max_length=100)
    city = models.CharField("Город", max_length=100)
    description = models.TextField("Описание", blank=True)
    logo = models.ImageField("Логотип", upload_to="suppliers/logos/%Y/%m/", blank=True)
    video_url = models.URLField("YouTube-видео", blank=True, validators=[URLValidator()])
    moq = models.PositiveIntegerField("Мин. заказ (MOQ)", default=1, validators=[MinValueValidator(1)])
    contact_email = models.EmailField("Контактный email", blank=True)
    contact_phone = models.CharField("Контактный телефон", max_length=20, blank=True)
    
    category = models.ForeignKey(
        Category,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="suppliers",
        verbose_name="Категория"
    )
    logistics_options = models.ManyToManyField(
        LogisticsCompany, 
        blank=True, 
        verbose_name="Варианты логистики"
    )
    
    created_at = models.DateTimeField("Создано", auto_now_add=True)
    updated_at = models.DateTimeField("Обновлено", auto_now=True)
    is_active = models.BooleanField("Активен", default=True)
    
    class Meta:
        verbose_name = "Поставщик"
        verbose_name_plural = "Поставщики"
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["country", "city"]),
            models.Index(fields=["category"]),
            models.Index(fields=["is_active", "created_at"]),
        ]

    def __str__(self):
        return f"{self.name} ({self.country})"
    
    def clean(self):
        if self.video_url and "youtube.com" not in self.video_url and "youtu.be" not in self.video_url:
            raise ValidationError({"video_url": "Только YouTube URL разрешены"})
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
EOF

cat > backend/apps/orders/models.py << 'EOF'
from django.db import models
from django.contrib.auth import get_user_model
from django.core.validators import MinValueValidator
from django.core.exceptions import ValidationError
from django.utils import timezone

User = get_user_model()

class Order(models.Model):
    STATUS_CHOICES = [
        ('active', 'Активный'),
        ('completed', 'Завершен'),
        ('cancelled', 'Отменен'),
        ('on_hold', 'На удержании'),
    ]
    
    title = models.CharField("Название заказа", max_length=200)
    description = models.TextField("Описание")
    buyer = models.ForeignKey(User, on_delete=models.CASCADE, related_name="orders")
    category = models.ForeignKey(
        'suppliers.Category', 
        on_delete=models.PROTECT, 
        null=True,
        verbose_name="Категория"
    )
    budget_min = models.DecimalField(
        "Мин. бюджет", 
        max_digits=12, 
        decimal_places=2, 
        null=True, 
        blank=True,
        validators=[MinValueValidator(0)]
    )
    budget_max = models.DecimalField(
        "Макс. бюджет", 
        max_digits=12, 
        decimal_places=2, 
        null=True, 
        blank=True,
        validators=[MinValueValidator(0)]
    )
    region = models.CharField("Регион поставки", max_length=100)
    deadline = models.DateField("Срок подачи предложений")
    status = models.CharField(
        "Статус", 
        max_length=20, 
        choices=STATUS_CHOICES, 
        default='active'
    )
    created_at = models.DateTimeField("Создан", auto_now_add=True)
    updated_at = models.DateTimeField("Обновлен", auto_now=True)
    is_urgent = models.BooleanField("Срочный", default=False)
    
    class Meta:
        verbose_name = "Заказ"
        verbose_name_plural = "Заказы"
        ordering = ["-is_urgent", "-created_at"]
        indexes = [
            models.Index(fields=["status", "created_at"]),
            models.Index(fields=["buyer", "created_at"]),
            models.Index(fields=["category", "status"]),
        ]

    def __str__(self):
        return f"#{self.id} {self.title}"
    
    def clean(self):
        if self.deadline <= timezone.now().date():
            raise ValidationError({"deadline": "Срок должен быть в будущем"})
        
        if self.budget_min and self.budget_max:
            if self.budget_min > self.budget_max:
                raise ValidationError({
                    "budget_min": "Минимум не может быть больше максимума",
                    "budget_max": "Максимум должен быть больше минимума"
                })
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

class Offer(models.Model):
    order = models.ForeignKey(
        Order, 
        on_delete=models.CASCADE, 
        related_name="offers",
        verbose_name="Заказ"
    )
    supplier = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name="offers",
        verbose_name="Поставщик"
    )
    price = models.DecimalField(
        "Цена", 
        max_digits=12, 
        decimal_places=2,
        validators=[MinValueValidator(0)]
    )
    delivery_days = models.PositiveIntegerField(
        "Срок поставки (дни)",
        validators=[MinValueValidator(1)]
    )
    comment = models.TextField("Комментарий", blank=True)
    created_at = models.DateTimeField("Создано", auto_now_add=True)
    updated_at = models.DateTimeField("Обновлено", auto_now=True)
    is_selected = models.BooleanField("Выбрано", default=False)
    
    class Meta:
        verbose_name = "Предложение"
        verbose_name_plural = "Предложения"
        unique_together = ['order', 'supplier']
        ordering = ["price", "delivery_days"]

    def __str__(self):
        return f"Предложение #{self.id} к заказу #{self.order.id}"
    
    def save(self, *args, **kwargs):
        if self.order.status != 'active':
            raise ValidationError("Можно создавать предложения только к активным заказам")
        super().save(*args, **kwargs)

class Message(models.Model):
    order = models.ForeignKey(
        Order, 
        on_delete=models.CASCADE, 
        related_name='messages',
        verbose_name="Заказ"
    )
    sender = models.ForeignKey(
        User, 
        on_delete=models.CASCADE,
        verbose_name="Отправитель"
    )
    content = models.TextField("Сообщение")
    timestamp = models.DateTimeField("Время", auto_now_add=True)
    is_read = models.BooleanField("Прочитано", default=False)
    
    class Meta:
        verbose_name = "Сообщение"
        verbose_name_plural = "Сообщения"
        ordering = ['timestamp']
        indexes = [
            models.Index(fields=["order", "timestamp"]),
        ]

    def __str__(self):
        return f"Сообщение #{self.id} в заказе #{self.order.id}"
EOF

cd backend && python manage.py makemigrations && python manage.py migrate
git add backend/apps/suppliers/models.py backend/apps/orders/models.py
git commit -m "ЭТАП 4: Production-ready модели"

# ==== ЭТАП 5: API ПАГИНАЦИЯ И ВАЛИДАЦИЯ ====

cat >> backend/config/settings.py << 'EOF'

# Пагинация и rate limiting
REST_FRAMEWORK.update({
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "100/hour",
        "user": "1000/hour",
    },
})
EOF

cat > backend/apps/suppliers/views.py << 'EOF'
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters, generics
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from django.db.models import Prefetch
from .models import Supplier, Category, LogisticsCompany
from .serializers import SupplierSerializer, CategorySerializer, LogisticsSerializer
from rest_framework.pagination import PageNumberPagination

class StandardPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

class SupplierListAPIView(generics.ListAPIView):
    queryset = Supplier.objects.select_related('category').prefetch_related(
        'logistics_options'
    ).filter(is_active=True)
    serializer_class = SupplierSerializer
    pagination_class = StandardPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ["country", "category__slug", "city", "moq"]
    search_fields = ["name", "description", "country", "city"]
    ordering_fields = ["created_at", "moq", "name"]
    ordering = ["-created_at"]

class CategoryListAPIView(generics.ListAPIView):
    queryset = Category.objects.all()
    serializer_class = CategorySerializer
    permission_classes = [AllowAny]

class LogisticsListAPIView(generics.ListAPIView):
    queryset = LogisticsCompany.objects.all()
    serializer_class = LogisticsSerializer
    permission_classes = [AllowAny]

@api_view(["GET"])
@permission_classes([IsAuthenticated])
def supplier_contacts(request, pk):
    supplier = get_object_or_404(Supplier, pk=pk, is_active=True)
    return Response({
        "contact_email": supplier.contact_email,
        "contact_phone": supplier.contact_phone,
        "name": supplier.name,
    })
EOF

cat > backend/apps/suppliers/serializers.py << 'EOF'
from rest_framework import serializers
from .models import Supplier, Category, LogisticsCompany

class CategorySerializer(serializers.ModelSerializer):
    supplier_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Category
        fields = ["id", "name", "slug", "supplier_count"]
    
    def get_supplier_count(self, obj):
        return obj.suppliers.filter(is_active=True).count()

class LogisticsSerializer(serializers.ModelSerializer):
    class Meta:
        model = LogisticsCompany
        fields = ["id", "name", "site", "description"]

class SupplierSerializer(serializers.ModelSerializer):
    category = CategorySerializer(read_only=True)
    logistics_options = LogisticsSerializer(read_only=True, many=True)
    logo_url = serializers.SerializerMethodField()
    
    class Meta:
        model = Supplier
        fields = [
            "id", "name", "country", "city", "description", "logo", "logo_url",
            "video_url", "moq", "contact_email", "contact_phone", "category",
            "logistics_options", "created_at",
        ]
    
    def get_logo_url(self, obj):
        if obj.logo:
            return obj.logo.url
        return None
EOF

cat > backend/apps/orders/views.py << 'EOF'
from rest_framework import generics
from rest_framework.permissions import IsAuthenticated
from django.shortcuts import get_object_or_404
from django.db.models import Prefetch, Count
from .models import Order, Offer, Message
from .serializers import (
    OrderSerializer, 
    OfferSerializer, 
    OrderCreateSerializer,
    OfferCreateSerializer,
    MessageSerializer
)
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response
from rest_framework import status

class StandardPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

class OrderListAPIView(generics.ListAPIView):
    serializer_class = OrderSerializer
    pagination_class = StandardPagination
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return Order.objects.filter(
            status='active'
        ).select_related(
            'category', 'buyer'
        ).annotate(
            offers_count=Count('offers')
        ).order_by('-is_urgent', '-created_at')

class OrderCreateAPIView(generics.CreateAPIView):
    serializer_class = OrderCreateSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        serializer.save(buyer=self.request.user)

class OfferCreateAPIView(generics.CreateAPIView):
    serializer_class = OfferCreateSerializer
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        order_id = self.kwargs['order_id']
        order = get_object_or_404(Order, id=order_id, status='active')
        
        if Offer.objects.filter(order=order, supplier=request.user).exists():
            return Response(
                {"error": "Вы уже подавали предложение к этому заказу"}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save(order=order, supplier=request.user)
        
        return Response(serializer.data, status=status.HTTP_201_CREATED)

class MyOrdersAPIView(generics.ListAPIView):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return Order.objects.filter(
            buyer=self.request.user
        ).select_related('category').order_by('-created_at')

class OrderOffersAPIView(generics.ListAPIView):
    serializer_class = OfferSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        order_id = self.kwargs['order_id']
        order = get_object_or_404(Order, id=order_id, buyer=self.request.user)
        return Offer.objects.filter(order=order).select_related('supplier')
EOF

cat > backend/apps/orders/serializers.py << 'EOF'
from rest_framework import serializers
from django.utils import timezone
from .models import Order, Offer, Message

class OrderSerializer(serializers.ModelSerializer):
    category_name = serializers.CharField(source='category.name', read_only=True)
    buyer_email = serializers.EmailField(source='buyer.email', read_only=True)
    offers_count = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = Order
        fields = [
            'id', 'title', 'description', 'category_name', 'buyer_email',
            'budget_min', 'budget_max', 'region', 'deadline', 'status', 
            'created_at', 'is_urgent', 'offers_count'
        ]

class OrderCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = [
            'title', 'description', 'category', 'budget_min', 
            'budget_max', 'region', 'deadline', 'is_urgent'
        ]
    
    def validate_deadline(self, value):
        if value <= timezone.now().date():
            raise serializers.ValidationError("Срок должен быть в будущем")
        return value
    
    def validate(self, data):
        if data.get('budget_min') and data.get('budget_max'):
            if data['budget_min'] > data['budget_max']:
                raise serializers.ValidationError(
                    "Минимальный бюджет не может быть больше максимального"
                )
        return data

class OfferSerializer(serializers.ModelSerializer):
    supplier_email = serializers.EmailField(source='supplier.email', read_only=True)
    supplier_id = serializers.IntegerField(source='supplier.id', read_only=True)
    
    class Meta:
        model = Offer
        fields = [
            'id', 'price', 'delivery_days', 'comment', 
            'supplier_email', 'supplier_id', 'created_at', 'is_selected'
        ]

class OfferCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Offer
        fields = ['price', 'delivery_days', 'comment']
    
    def validate_price(self, value):
        if value <= 0:
            raise serializers.ValidationError("Цена должна быть положительной")
        return value
    
    def validate_delivery_days(self, value):
        if value < 1:
            raise serializers.ValidationError("Срок поставки минимум 1 день")
        return value

class MessageSerializer(serializers.ModelSerializer):
    sender_email = serializers.EmailField(source='sender.email', read_only=True)
    
    class Meta:
        model = Message
        fields = ['id', 'content', 'sender_email', 'timestamp', 'is_read']
EOF

cat > backend/config/urls.py << 'EOF'
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path("api/v1/auth/", include("apps.users.urls")),
    path("api/v1/auth/login/", TokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/v1/auth/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
    path("api/v1/suppliers/", include("apps.suppliers.urls")),
    path("api/v1/orders/", include("apps.orders.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
EOF

cat > backend/apps/users/urls.py << 'EOF'
from django.urls import path
from .views import RegisterView

app_name = "users"
urlpatterns = [
    path("", RegisterView.as_view(), name="register"),
]
EOF

cat > backend/apps/orders/urls.py << 'EOF'
from django.urls import path
from .views import (
    OrderListAPIView, OrderCreateAPIView, OfferCreateAPIView,
    MyOrdersAPIView, OrderOffersAPIView
)

app_name = "orders"

urlpatterns = [
    path("", OrderListAPIView.as_view(), name="order-list"),
    path("create/", OrderCreateAPIView.as_view(), name="order-create"),
    path("my/", MyOrdersAPIView.as_view(), name="my-orders"),
    path("my/<int:order_id>/offers/", OrderOffersAPIView.as_view(), name="order-offers"),
    path("<int:order_id>/offers/", OfferCreateAPIView.as_view(), name="offer-create"),
]
EOF

git add backend/config/settings.py backend/config/urls.py backend/apps/suppliers/views.py backend/apps/suppliers/serializers.py backend/apps/orders/views.py backend/apps/orders/serializers.py backend/apps/users/urls.py backend/apps/orders/urls.py
git commit -m "ЭТАП 5: Пагинация, валидация, rate limiting"

# ==== ЭТАП 6: FRONTEND ====

cat > frontend/.env.example << 'EOF'
VITE_API_BASE_URL=http://localhost:8000/api/v1
VITE_WS_URL=ws://localhost:8000
VITE_APP_NAME=Поставщик.РУ
EOF

cat > frontend/.env << 'EOF'
VITE_API_BASE_URL=http://localhost:8000/api/v1
VITE_WS_URL=ws://localhost:8000
VITE_APP_NAME=Поставщик.РУ
EOF

cat > frontend/package.json << 'EOF'
{
  "name": "lilili-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"src/**/*.{ts,tsx,css}\""
  },
  "dependencies": {
    "axios": "^1.7.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1",
    "react-query": "^3.39.3",
    "react-hook-form": "^7.51.5",
    "react-hot-toast": "^2.4.1",
    "react-icons": "^5.2.1",
    "zustand": "^4.5.2",
    "clsx": "^2.1.1"
  },
  "devDependencies": {
    "@types/node": "^20.14.2",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "postcss": "^8.4.38",
    "prettier": "^3.3.2",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}
EOF

cd frontend && npm install
mkdir -p frontend/src/{hooks,services,utils,types,store,pages}

cat > frontend/src/types/index.ts << 'EOF'
export interface User {
  id: number;
  email: string;
}

export interface Category {
  id: number;
  name: string;
  slug: string;
}

export interface LogisticsCompany {
  id: number;
  name: string;
  site: string;
}

export interface Supplier {
  id: number;
  name: string;
  country: string;
  city: string;
  description: string;
  logo?: string;
  logo_url?: string;
  video_url?: string;
  moq: number;
  contact_email?: string;
  contact_phone?: string;
  category: Category;
  logistics_options: LogisticsCompany[];
  created_at: string;
}

export interface Order {
  id: number;
  title: string;
  description: string;
  category_name: string;
  buyer_email: string;
  budget_min?: number;
  budget_max?: number;
  region: string;
  deadline: string;
  status: string;
  created_at: string;
  is_urgent: boolean;
  offers_count: number;
}

export interface Offer {
  id: number;
  price: number;
  delivery_days: number;
  comment?: string;
  supplier_email: string;
  supplier_id: number;
  created_at: string;
  is_selected: boolean;
}

export interface Message {
  id: number;
  content: string;
  sender_email: string;
  timestamp: string;
  is_read: boolean;
}

export interface PaginatedResponse<T> {
  count: number;
  next: string | null;
  previous: string | null;
  results: T[];
}
EOF

git add frontend/.env.example frontend/.env frontend/package.json frontend/src/types/
git commit -m "ЭТАП 6: Frontend production setup"

# ==== ЭТАП 7: DOCKER И DEPLOYMENT ====

cat > backend/Dockerfile << 'EOF'
FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN mkdir -p /app/media
RUN python manage.py collectstatic --noinput

EXPOSE 8000

CMD ["daphne", "-b", "0.0.0.0", "-p", "8000", "config.asgi:application"]
EOF

cat > frontend/Dockerfile << 'EOF'
FROM node:20-alpine as builder

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
EOF

cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: lilili_prod
      POSTGRES_USER: lilili_user
      POSTGRES_PASSWORD: ${DB_PASSWORD:-changeme}
    volumes:
      - pg_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U lilili_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    command: daphne -b 0.0.0.0 -p 8000 config.asgi:application
    volumes:
      - ./backend:/app
      - media_volume:/app/media
    environment:
      DATABASE_URL: postgresql://lilili_user:${DB_PASSWORD:-changeme}@db:5432/lilili_prod
      REDIS_URL: redis://redis:6379
      SECRET_KEY: ${SECRET_KEY}
      DEBUG: ${DEBUG:-False}
      ALLOWED_HOSTS: ${ALLOWED_HOSTS:-localhost}
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-http://localhost:5173}
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

  frontend:
    build: ./frontend
    ports:
      - "5173:80"
    environment:
      VITE_API_BASE_URL: ${VITE_API_BASE_URL:-http://localhost:8000/api/v1}
      VITE_WS_URL: ${VITE_WS_URL:-ws://localhost:8000}

  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - media_volume:/app/media
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
      - frontend

volumes:
  pg_data:
  media_volume:
EOF

cat > Makefile << 'EOF'
.PHONY: install migrate run test build docker-up docker-down

install:
	cd backend && pip install -r requirements.txt
	cd frontend && npm install

migrate:
	cd backend && python manage.py migrate

run-backend:
	cd backend && python manage.py runserver

run-frontend:
	cd frontend && npm run dev

test-backend:
	cd backend && python manage.py test

test-frontend:
	cd frontend && npm test

docker-up:
	docker-compose up -d --build

docker-down:
	docker-compose down

docker-logs:
	docker-compose logs -f

build-backend:
	cd backend && docker build -t lilili-backend .

build-frontend:
	cd frontend && docker build -t lilili-frontend .

release: docker-down docker-up
	@echo "Production release complete!"
EOF

git add backend/Dockerfile frontend/Dockerfile docker-compose.yml Makefile
git commit -m "ЭТАП 7: Docker и deployment setup"

# ==== ЭТАП 8: КОНФИГУРАЦИЯ ПРОДАКШЕНА ====

cat > backend/apps/users/tests.py << 'EOF'
from django.test import TestCase
from django.contrib.auth import get_user_model
from rest_framework.test import APIClient
from rest_framework import status

User = get_user_model()

class UsersAPITestCase(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user_data = {
            'email': 'test@example.com',
            'password': 'testpass123'
        }
        self.user = User.objects.create_user(**self.user_data)
    
    def test_register_user(self):
        response = self.client.post('/api/v1/auth/', {
            'email': 'newuser@example.com',
            'password': 'newpass123'
        })
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertIn('access', response.data)
    
    def test_login_user(self):
        response = self.client.post('/api/v1/auth/login/', self.user_data)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('access', response.data)
EOF

cat > README.md << 'EOF'
# Lilili B2B Platform

## Описание
Платформа для поиска поставщиков и управления закупками в реальном времени.

## Стек технологий
- **Backend**: Django 5, DRF, Channels, Redis
- **Frontend**: React 18, TypeScript, Vite, Tailwind
- **Database**: PostgreSQL (prod) / SQLite (dev)
- **Real-time**: WebSockets

## Быстрый старт

### Development
```bash
make install
make migrate
make run-backend  # в одном терминале
make run-frontend # во втором терминале